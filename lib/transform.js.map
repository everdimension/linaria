{"version":3,"sources":["../src/transform.js"],"names":["path","require","babel","stylis","SourceMapGenerator","STYLIS_DECLARATION","module","exports","transform","code","options","test","sourceMap","inputSourceMap","ast","parseSync","filename","caller","name","transformFromAstSync","presets","resolve","pluginOptions","babelrc","configFile","sourceMaps","sourceFileName","metadata","transformedCode","map","linaria","rules","replacements","dependencies","mappings","cssText","preprocessor","selector","text","use","context","decl","outputFilename","replace","match","p1","p2","p3","relative","dirname","Object","keys","forEach","index","push","generated","line","column","original","start","cssSourceMapText","length","generator","file","mapping","addMapping","assign","source","setSourceContent","toString"],"mappings":"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","sourcesContent":["/* @flow */\n\nimport type { Options as PluginOptions } from './babel/extract';\n\nconst path = require('path');\nconst babel = require('@babel/core');\nconst stylis = require('stylis');\nconst { SourceMapGenerator } = require('source-map');\n\ntype Location = {\n  line: number,\n  column: number,\n};\n\ntype Result = {\n  code: string,\n  sourceMap: ?Object,\n  cssText?: string,\n  cssSourceMapText?: string,\n  dependencies?: string[],\n  rules?: {\n    [className: string]: {\n      cssText: string,\n      displayName: string,\n      start: ?Location,\n    },\n  },\n  replacements?: Array<{\n    original: { start: Location, end: Location },\n    length: number,\n  }>,\n};\n\ntype Options = {\n  filename: string,\n  preprocessor?: Preprocessor,\n  outputFilename?: string,\n  inputSourceMap?: Object,\n  pluginOptions?: $Shape<PluginOptions>,\n};\n\nexport type Preprocessor =\n  | 'none'\n  | 'stylis'\n  | ((selector: string, cssText: string) => string)\n  | void;\n\nconst STYLIS_DECLARATION = 1;\n\nmodule.exports = function transform(code: string, options: Options): Result {\n  // Check if the file contains `css` or `styled` words first\n  // Otherwise we should skip transforming\n  if (!/\\b(styled|css)/.test(code)) {\n    return {\n      code,\n      sourceMap: options.inputSourceMap,\n    };\n  }\n\n  // Parse the code first so babel uses user's babel config for parsing\n  // We don't want to use user's config when transforming the code\n  const ast = babel.parseSync(code, {\n    filename: options.filename,\n    caller: { name: 'linaria' },\n  });\n\n  const { metadata, code: transformedCode, map } = babel.transformFromAstSync(\n    ast,\n    code,\n    {\n      filename: options.filename,\n      presets: [[require.resolve('./babel'), options.pluginOptions]],\n      babelrc: false,\n      configFile: false,\n      sourceMaps: true,\n      sourceFileName: options.filename,\n      inputSourceMap: options.inputSourceMap,\n    }\n  );\n\n  if (!metadata.linaria) {\n    return {\n      code,\n      sourceMap: options.inputSourceMap,\n    };\n  }\n\n  const { rules, replacements, dependencies } = metadata.linaria;\n  const mappings = [];\n\n  let cssText = '';\n\n  let preprocessor;\n\n  if (typeof options.preprocessor === 'function') {\n    // eslint-disable-next-line prefer-destructuring\n    preprocessor = options.preprocessor;\n  } else {\n    switch (options.preprocessor) {\n      case 'none':\n        preprocessor = (selector, text) => `${selector} {${text}}\\n`;\n        break;\n      case 'stylis':\n      default:\n        stylis.use(null)((context, decl) => {\n          if (context === STYLIS_DECLARATION && options.outputFilename) {\n            // When writing to a file, we need to adjust the relative paths inside url(..) expressions\n            // It'll allow css-loader to resolve an imported asset properly\n            return decl.replace(\n              /\\b(url\\()(\\.[^)]+)(\\))/g,\n              (match, p1, p2, p3) =>\n                p1 +\n                // Replace asset path with new path relative to the output CSS\n                path.relative(\n                  /* $FlowFixMe */\n                  path.dirname(options.outputFilename),\n                  // Get the absolute path to the asset from the path relative to the JS file\n                  path.resolve(path.dirname(options.filename), p2)\n                ) +\n                p3\n            );\n          }\n\n          return decl;\n        });\n\n        preprocessor = stylis;\n    }\n  }\n\n  Object.keys(rules).forEach((selector, index) => {\n    mappings.push({\n      generated: {\n        line: index + 1,\n        column: 0,\n      },\n      original: rules[selector].start,\n      name: selector,\n    });\n\n    // Run each rule through stylis to support nesting\n    cssText += `${preprocessor(selector, rules[selector].cssText)}\\n`;\n  });\n\n  return {\n    code: transformedCode,\n    cssText,\n    rules,\n    replacements,\n    dependencies,\n    sourceMap: map,\n\n    get cssSourceMapText() {\n      if (mappings && mappings.length) {\n        const generator = new SourceMapGenerator({\n          file: options.filename.replace(/\\.js$/, '.css'),\n        });\n\n        mappings.forEach(mapping =>\n          generator.addMapping(\n            Object.assign({}, mapping, { source: options.filename })\n          )\n        );\n\n        generator.setSourceContent(options.filename, code);\n\n        return generator.toString();\n      }\n\n      return '';\n    },\n  };\n};\n"],"file":"transform.js"}